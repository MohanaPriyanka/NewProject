/**
 * Created by mstackhouse on 12/12/2018.
 * Description: Moving Logic for CS Subscriptions out of LeadTriggerHandler.
 * Dependencies: Leads, SharedSolarSystems
 *
 * Outputs: Opportunities for leads, Utility Account Subscriptions for leads
 * Test: LeadTriggerHandlerTest, LeadServiceTestclass
 */

@SuppressWarnings('PMD.ApexCRUDViolation')
public without sharing class CSSubscriptionEnroller {
    @TestVisible private static FeatureService featureService = new FeatureService();
    @TestVisible private static SharedSolarSystemsSelector sssSelector = new SharedSolarSystemsSelector();

    private List<Lead> leads;
    private Map<Id, Lead> leadIdToLeadWithChildren;
    @TestVisible private SharedSolarSystems sssList;
    private Map<Id, Product2> productsMap;
    private Map<Id, List<Shared_Solar_System__c>> leadIdToAvailableSSS;
    private Map<Id, List<Opportunity>> leadOppsMap;
    private Map<Id, Account> accountIdToAccountWithContacts;
    private List<CSUtilityAccountSubscriptionFactory.UASOrder> uasOrders;


    private fflib_SObjectUnitOfWork uow = new fflib_SObjectUnitOfWork(
        new List<Schema.SObjectType> {
            Utility_Account_Log__c.SObjectType,
            Contract.SObjectType,
            Opportunity.SObjectType,
            OpportunityContactRole.SObjectType,
            Utility_Account_Subscription__c.SObjectType,
            Subscription_Order__c.SObjectType
        }
    );


    public CSSubscriptionEnroller(List<Lead> leads) {
        this.leads = leads;

        Set<Id> leadIds = new Set<Id>();
        Set<Id> parentAccountIds = new Set<Id>();
        for (Lead lead : leads) {
            leadIds.add(lead.Id);
            if(lead.ConvertedAccountId != null) {
                parentAccountIds.add(lead.ConvertedAccountId);
            }
        }
        
        leadIdToLeadWithChildren = new Map<Id, Lead>([
            SELECT Id,
                (SELECT Id, Name, Annual_Cost_of_Electricity__c, Annual_kWh__c, Lead__c, 
                    Lead__r.Product__r.Customer_Subscription_Type__c, Name_on_Account__c, Proposed_kWh__c, 
                    Subsc_Annual_Cost_of_Electricity_Rollup__c, Subscribed_Annual_kWhs_Rollup__c, 
                    Subscribed_Annual_Cost_of_Electricity__c, Subscribed_Annual_kWhs__c, Utility__c, 
                    Utility_NMC_Tariff__c, Utility_Rate_Class__c, Utility_Rate_Class__r.Utility_NMC_Tariff__r.Size_Ratio__c
                FROM Utility_Account_Logs__r
                ORDER BY Annual_Cost_of_Electricity__c, Annual_kWh__c DESC),
                (SELECT Id FROM Accounts__r WHERE RecordType.Name = 'Property'),
                (SELECT Id, AccountId, Contract_Type__c, Customer_Signature_Date_Time__c, Product__c
                FROM Contracts__r WHERE RecordTypeId = :CustomerContractService.RECORD_TYPE_ID
                ORDER BY CreatedDate DESC)
            FROM Lead
            WHERE Id = :leadIds
        ]);
        
        sssList = new SharedSolarSystems(sssSelector.getSharedSolarSystemsForEnrollment());

        productsMap = new Map<Id, Product2>([
            SELECT Id, Program__c, Sizing_Method__c, Customer_Subscription_Type__c,
                (SELECT Id, Name, Size_Ratio__c, Utility_NMC_Tariff__r.Customer_Type__c,
                    Utility_NMC_Tariff__r.Minimum_kWh__c, Utility_NMC_Tariff__r.Maximum_kWh__c,
                    Utility_NMC_Tariff__r.Utility_Relationship__c, Utility_NMC_Tariff__c
                FROM Product_Tariffs__r)
            FROM Product2
            WHERE Product_Type__c = 'Community Solar'
        ]);

        accountIdToAccountWithContacts = new Map<Id, Account>([
            SELECT Id, (SELECT Id FROM Contacts)
            FROM Account WHERE Id = :parentAccountIds
        ]);


        leadOppsMap = new Map<Id, List<Opportunity>>();
        leadIdToAvailableSSS = new Map<Id, List<Shared_Solar_System__c>>();
        uasOrders = new List<CSUtilityAccountSubscriptionFactory.UASOrder>();
    }


    public void enroll() {
        for (Lead lead : leads) {
            if (!featureService.isEnabled('Sizing_Method')) {
                calculateProposedkWh(lead);
            }
            AnnualEnergyTotal annualTotals = getAnnualTotals(lead);
            if (annualTotals.cost != 0 || annualTotals.kWh != 0) {
                createOpportunityAndContactRoles(lead, annualTotals);
                createUAS(lead);
                if (lead.Zuora_Payment_Ref_Id__c != null) {
                    System.enqueueJob(new ZuoraAccountAsyncService(lead.Id));
                }
            }
        }
        
        try {
            uow.commitWork();
        } catch (Exception ex) {
            Logger.logLater(
                'CSSubscriptionEnroller', 
                'enroll', 
                ex.getMessage() + '\n' + ex.getStackTraceString()
            );
        }
        Logger.flushLogs();
    }


    private void calculateProposedkWh(Lead lead) {
        Product2 product = productsMap.get(lead.Product__c);
        for (Utility_Account_Log__c ual : leadIdToLeadWithChildren.get(lead.Id).Utility_Account_Logs__r) {
            Product_Tariff__c tariff = assignUtilityTariff(ual, lead, product.Product_Tariffs__r);
            if (tariff != null && product != null && ual.Annual_kWh__c != null) {
                ual.Utility_NMC_Tariff__c = tariff.Utility_NMC_Tariff__c;
                ual.Product_Tariff__c = tariff.Id;
                // Currently, we only need to have a sizing ratio for SMART
                Decimal sizeRatio;
                if (tariff.Size_Ratio__c != null) {
                    sizeRatio = tariff.Size_Ratio__c;
                } else {
                    sizeRatio = 1.0;
                }
                ual.Proposed_kWh__c = ual.Annual_kWh__c * sizeRatio;
            } else {
                ual.Proposed_kWh__c = ual.Annual_kWh__c;
            }
            uow.registerDirty(ual);
        }
    }


    private Product_Tariff__c assignUtilityTariff(Utility_Account_Log__c ual, Lead lead, List<Product_Tariff__c> tariffs) {
        if (tariffs == null) {
            return null;
        }
        
        Product_Tariff__c assignedTariff;
        for (Product_Tariff__c tariff : tariffs) {
            if (lead.Customer_type__c == tariff.Utility_NMC_Tariff__r.Customer_type__c
                    && lead.Utility_relationship__c == tariff.Utility_NMC_Tariff__r.Utility_Relationship__c
                    && (tariff.Utility_NMC_Tariff__r.Maximum_kWh__c == null || ual.Annual_kWh__c < tariff.Utility_NMC_Tariff__r.Maximum_kWh__c)
                    && (tariff.Utility_NMC_Tariff__r.Minimum_kWh__c == null || ual.Annual_kWh__c >= tariff.Utility_NMC_Tariff__r.Minimum_kWh__c)) {
                if (assignedTariff == null) {
                    assignedTariff = tariff;
                } else {
                    String message = 'Lead ' + lead.Id + ' meets the criteria for multiple tariffs.';
                    message += ' Assigned Tariff: ' + assignedTariff;
                    message += ' Other Qualified Tariff: ' + tariff;
                    Logger.logLater('CSSubscriptionEnroller', 'assignUtilityTariff', message);
                }
            }
        }
        return assignedTariff;
    }


    private AnnualEnergyTotal getAnnualTotals(Lead lead) {
        Decimal totalAnnualCostOfElectricity = 0;
        Decimal totalAnnualkWhElectricity = 0;
        for (Utility_Account_Log__c ual : leadIdToLeadWithChildren.get(lead.Id).Utility_Account_Logs__r) {
            if ((ual.Annual_Cost_of_Electricity__c == null && productsMap.get(lead.Product__c).Customer_Subscription_Type__c == 'Electricity Cost ($)')
                || ( ual.Annual_kWh__c == null && productsMap.get(lead.Product__c).Customer_Subscription_Type__c == 'kWh' )) {
                throw new Util.BWException('No Annual Usage populated on UALs. Please enter usage before converting');
            }

            totalAnnualCostOfElectricity += Util.nullToZero(ual.Annual_Cost_of_Electricity__c);
            totalAnnualCostOfElectricity -= Util.nullToZero(ual.Subsc_Annual_Cost_of_Electricity_Rollup__c);
            totalAnnualkWhElectricity -= Util.nullToZero(ual.Subscribed_Annual_kWhs_Rollup__c);

            if (productsMap.get(lead.Product__c).Sizing_Method__c == 'Rate Class Ratio' && productsMap.get(lead.Product__c).Customer_Subscription_Type__c == 'kWh') {
                try {
                    totalAnnualkWhElectricity += Util.nullToZero((ual.Annual_kWh__c * ual.Utility_Rate_Class__r.Utility_NMC_Tariff__r.Size_Ratio__c));
                } catch (System.NullPointerException e) {
                    throw new Util.BWException('Utility Account Log is missing required information for sizing. Confirm that the UAL has: ' + '\n' +
                        '1. Rate Class on UAL' + '\n' +
                        '2. Rate Class has a Sizing Method with a Size Ratio'
                    );
                }
            } else {
                totalAnnualkWhElectricity += Util.nullToZero(ual.Annual_kWh__c);
            }
        }
        return new AnnualEnergyTotal(totalAnnualCostOfElectricity, totalAnnualkWhElectricity);
    }


    private void createOpportunityAndContactRoles(Lead lead, AnnualEnergyTotal annualTotals) {
        Id propertyAccountId = getPropertyAccount(lead);
        List<Shared_Solar_System__c> availableSSS = sssList.getQualifiedForLead(lead);
        leadIdToAvailableSSS.put(lead.Id, availableSSS);
        
        //Need to pass the property Account here (not converted Account)
        List<Opportunity> oppListToCreate = CSOpportunityFactory.generateCSOpportunities(lead, availableSSS, annualTotals, propertyAccountId);
        leadOppsMap.put(lead.Id, oppListToCreate);
        for(Opportunity opp : oppListToCreate) {
            List<Contract> leadContracts = leadIdToLeadWithChildren.get(lead.Id).Contracts__r;
            if(!leadContracts.isEmpty()) {
                Contract parentContract = leadContracts[0];
                if(parentContract.Contract_Type__c == 'Generic') {
                    Contract oppContract = CustomerContractService.createForOpportunity(opp, parentContract);
                    uow.registerNew(oppContract);
                    uow.registerNew(opp, Opportunity.ContractId, oppContract);
                } else {
                    uow.registerNew(opp, Opportunity.ContractId, parentContract);
                }
            } else {
                uow.registerNew(opp);
            }
        }
        
        if(accountIdToAccountWithContacts.containsKey(lead.ConvertedAccountId)) {
            for(Contact contact : accountIdToAccountWithContacts.get(lead.ConvertedAccountId).Contacts) {
                for(Opportunity opp : oppListToCreate) {
                    uow.registerNew(
                        new OpportunityContactRole(
                            ContactId = contact.Id,
                            Role = 'Customer',
                            IsPrimary = true
                        ),
                        OpportunityContactRole.OpportunityId,
                        opp
                    );
                }
            }
        }
    }


    private Id getPropertyAccount(Lead lead) {
        Id propAccountId;
        //If Switch lead, the property account will be in the list already. If CSAP Lead, will need to grab the Converted Account
        if (!leadIdToLeadWithChildren.get(lead.Id).Accounts__r.isEmpty()){
            return leadIdToLeadWithChildren.get(lead.Id).Accounts__r[0].Id;
        } else if (lead.IsConverted && lead.ConvertedAccountId != null) {
            propAccountId = lead.ConvertedAccountId;
        }
        return propAccountId;
    }

    private void createUAS(Lead lead) {
        List<Shared_Solar_System__c> sharedSolarSystems = leadIdToAvailableSSS.get(lead.Id);
        List<Opportunity> opportunities = leadOppsMap.get(lead.Id);
        List<Utility_Account_Log__c> uals = leadIdToLeadWithChildren.get(lead.Id).Utility_Account_Logs__r;

        // if UALs aren't sorted by the field matching their subscription type and both annual kwh and annual cost are populated,
        //  UASes aren't assigned appropriately
        if(lead.Product__r.Customer_Subscription_Type__c == 'kWh') {
            CollectionUtil.sort(uals, Comparators.sobjectFieldValueComparator(Utility_Account_Log__c.Annual_kWh__c).ascending(false).nullsFirst(false));
        } else {
            CollectionUtil.sort(uals, Comparators.sobjectFieldValueComparator(Utility_Account_Log__c.Annual_Cost_of_Electricity__c).ascending(false).nullsFirst(false));
        }
        
        CSUtilityAccountSubscriptionFactory.generateSubscriptions(uals, sharedSolarSystems, opportunities, uow);
    }

    

    public class AnnualEnergyTotal {
        public Decimal cost;
        public Decimal kWh;

        public AnnualEnergyTotal(Decimal cost, Decimal kWh) {
            this.cost = cost.setScale(0);
            this.kWh = kWh.setScale(0);
        }
    }
}